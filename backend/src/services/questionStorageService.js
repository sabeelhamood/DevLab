import { randomUUID } from 'node:crypto'
import { QuestionModel } from '../models/Question.js'
import { postgres } from '../config/database.js'
import { getSupabaseTables } from '../config/database.js'

const tables = getSupabaseTables()
const questionsTable = '"questions"'
const testCasesTable = '"testCases"'

// Default course_id to use when course_id is not provided
// This should be set to an existing course UUID in your database
// If not set, the system will try to find/create a course by name
const DEFAULT_COURSE_ID = process.env.DEFAULT_COURSE_ID || null

/**
 * Service to save questions generated by Content Studio/Gemini to Supabase
 * 
 * This service handles:
 * - Saving questions to the questions table
 * - Saving test cases for coding questions
 * - Storing options and correct answers in metadata
 * - Marking source (content-studio or gemini-question-generation)
 * - Preventing duplicates
 * - Auto-creating topics if they don't exist (requires course_id)
 */

/**
 * Save a single question to Supabase
 * @param {Object} questionData - Question data from Content Studio
 * @param {Object} metadata - Additional metadata (topic_id, topic_name, etc.)
 * @returns {Promise<Object>} Saved question with question_id
 */
export const saveQuestionToSupabase = async (questionData, metadata = {}) => {
  try {
    // Extract question data - handle both flat structure and nested ajax structure
    const {
      id, // Temporary ID from Content Studio
      question, // Question text/content
      question_text, // Alternative field name
      question_content, // Alternative field name
      prompt, // Alternative field name
      question_type, // 'code' or 'theoretical'
      topic_id,
      topic_name,
      difficulty,
      programming_language,
      language,
      test_cases = [],
      testCases = [],
      hints = [],
      clues = [],
      options = [],
      correct_answer,
      expectedAnswer,
      title,
      topicId,
      topicName,
      ajax, // Nested ajax object that might contain additional data
      _rawGeminiResponse // Raw Gemini API response (stored for debugging/analysis)
    } = questionData

    // Extract data from ajax object if it exists (for theoretical questions)
    const ajaxData = ajax || {}
    const ajaxQuestion = ajaxData.question || ajaxData.prompt || null
    const ajaxExpectedAnswer = ajaxData.expectedAnswer || ajaxData.expected_answer || ajaxData.correctAnswer || null
    const ajaxOptions = ajaxData.options || null // Options for multiple choice questions
    const ajaxTestCases = ajaxData.testCases || ajaxData.test_cases || []
    const ajaxHints = ajaxData.hints || []
    
    // Extract metadata (must be before resolving options to use in metadata)
    const {
      topic_id: metaTopicId,
      topic_name: metaTopicName,
      question_type: metaQuestionType,
      programming_language: metaProgrammingLanguage,
      course_id: metaCourseId,
      course_name: metaCourseName,
      skills = [],
      humanLanguage = 'en',
      source = 'content-studio'
    } = metadata

    // Resolve question content (check multiple possible fields)
    const questionContent = question || question_text || question_content || prompt || ajaxQuestion || ''
    if (!questionContent) {
      throw new Error('Question content is required')
    }
    
    // Resolve test cases (check multiple possible fields)
    const resolvedTestCases = test_cases.length > 0 ? test_cases : 
                              testCases.length > 0 ? testCases : 
                              ajaxTestCases.length > 0 ? ajaxTestCases : []
    
    // Resolve hints/clues (check multiple possible fields)
    const resolvedHints = hints.length > 0 ? hints : 
                          clues.length > 0 ? clues : 
                          ajaxHints.length > 0 ? ajaxHints : []
    
    // Resolve correct answer/expected answer (for theoretical questions)
    const resolvedCorrectAnswer = correct_answer || expectedAnswer || ajaxExpectedAnswer || null
    
    // Check if options is an object (like {A: "...", B: "...", C: "...", D: "..."}) and convert to array
    let resolvedOptions = options || ajaxOptions || []
    if (resolvedOptions && typeof resolvedOptions === 'object' && !Array.isArray(resolvedOptions)) {
      // Convert object to array format: [{label: 'A', text: '...'}, {label: 'B', text: '...'}]
      resolvedOptions = Object.entries(resolvedOptions).map(([label, text]) => ({
        label: String(label),
        text: String(text)
      }))
    } else if (!Array.isArray(resolvedOptions)) {
      resolvedOptions = []
    }

    // ============================================================================
    // STEP 1: Resolve course_id (required for topic creation)
    // ============================================================================
    // Priority order:
    // 1. From metadata.course_id (explicit)
    // 2. Lookup by course_name in courses table
    // 3. Use DEFAULT_COURSE_ID from environment
    // 4. null (will log warning and skip topic creation)
    // ============================================================================
    let resolvedCourseId = metaCourseId || course_id || null
    
    // Try to find course by course_name if course_id is not provided
    if (!resolvedCourseId && (metaCourseName || metadata.course_name)) {
      const courseNameToSearch = metaCourseName || metadata.course_name
      try {
        // Look up course by name (courses table might have course_name or name field)
        const courseLookup = await postgres.query(
          `SELECT "course_id" FROM "courses" 
           WHERE "course_name" = $1::text 
              OR "name" = $1::text
              OR "title" = $1::text
           LIMIT 1`,
          [courseNameToSearch]
        )
        if (courseLookup.rows.length > 0) {
          resolvedCourseId = courseLookup.rows[0].course_id
          console.log(`‚úÖ Found course: ${resolvedCourseId} for course_name: "${courseNameToSearch}"`)
        }
      } catch (courseError) {
        console.warn(`‚ö†Ô∏è Could not lookup course by name: ${courseError.message}`)
      }
    }
    
    // Use DEFAULT_COURSE_ID if still not resolved
    if (!resolvedCourseId && DEFAULT_COURSE_ID) {
      resolvedCourseId = DEFAULT_COURSE_ID
      console.log(`‚úÖ Using DEFAULT_COURSE_ID: ${resolvedCourseId}`)
    }
    
    // Log warning if course_id is still missing (will prevent topic creation)
    if (!resolvedCourseId) {
      console.warn(`‚ö†Ô∏è Cannot create topic: course_id missing ‚Äî skipping topic creation`)
      console.warn(`   Topic name: "${topic_name || topicName || metaTopicName || 'N/A'}"`)
      console.warn(`   Course name: "${metaCourseName || metadata.course_name || 'N/A'}"`)
      console.warn(`   Set DEFAULT_COURSE_ID environment variable or provide course_id in metadata`)
    }

    // ============================================================================
    // STEP 2: Resolve topic_id (can be UUID or string that needs conversion)
    // ============================================================================
    let resolvedTopicId = topic_id || topicId || metaTopicId
    if (!resolvedTopicId) {
      throw new Error('topic_id is required')
    }

    // Handle topic_id - it might be a UUID string or a string identifier
    // For Content Studio, topic_id is typically a string identifier like "301", "302", etc.
    // We need to convert it to UUID format or look it up in the topics table
    let topicIdUuid = resolvedTopicId
    
    // Check if it's already a UUID format
    const isUuidFormat = typeof resolvedTopicId === 'string' && 
      resolvedTopicId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)
    
    if (!isUuidFormat) {
      // Try to find the topic in the topics table by topic_name
      // Content Studio may send topic_id as a string identifier, so we look up by name
      const topicNameToSearch = topic_name || topicName || metaTopicName || ''
      
      if (topicNameToSearch) {
        try {
          const topicLookup = await postgres.query(
            `SELECT "topic_id", "course_id" FROM "topics" 
             WHERE "topic_name" = $1::text 
             LIMIT 1`,
            [topicNameToSearch]
          )
          
          if (topicLookup.rows.length > 0) {
            topicIdUuid = topicLookup.rows[0].topic_id
            // Extract course_id from topic if not already provided
            if (!resolvedCourseId && topicLookup.rows[0].course_id) {
              resolvedCourseId = topicLookup.rows[0].course_id
              console.log(`‚úÖ Extracted course_id from topic: ${resolvedCourseId}`)
            }
            console.log(`‚úÖ Found topic UUID: ${topicIdUuid} for topic_name: "${topicNameToSearch}"`)
            if (topicLookup.rows[0].course_id) {
              console.log(`   Course ID: ${topicLookup.rows[0].course_id}`)
            }
          } else {
            // Topic doesn't exist - try to create it automatically if course_id is available
            console.log(`‚ö†Ô∏è Topic not found in database for topic_name: "${topicNameToSearch}"`)
            
            if (!resolvedCourseId) {
              // Cannot create topic without course_id
              console.warn(`‚ö†Ô∏è Cannot create topic: course_id missing ‚Äî skipping topic creation`)
              console.warn(`   Topic: "${topicNameToSearch}"`)
              console.warn(`   Course name: "${metaCourseName || metadata.course_name || 'N/A'}"`)
              console.warn(`   Set DEFAULT_COURSE_ID environment variable or provide course_id in metadata`)
              throw new Error(`Topic "${topicNameToSearch}" not found and cannot be created without course_id. Please create the topic manually or set DEFAULT_COURSE_ID.`)
            }
            
            // Create topic automatically with resolved course_id
            console.log(`   Attempting to create topic automatically with course_id: ${resolvedCourseId}...`)
            
            try {
              const newTopicId = randomUUID()
              const createTopicQuery = `
                INSERT INTO "topics" (
                  "topic_id",
                  "course_id",
                  "topic_name",
                  "skills",
                  "created_at",
                  "updated_at"
                ) VALUES (
                  $1::uuid,
                  $2::uuid,
                  $3::text,
                  $4::jsonb,
                  now(),
                  now()
                )
                ON CONFLICT ("topic_id") DO NOTHING
                RETURNING "topic_id", "course_id"
              `
              
              const createTopicResult = await postgres.query(createTopicQuery, [
                newTopicId,
                resolvedCourseId,
                topicNameToSearch,
                JSON.stringify(Array.isArray(skills) ? skills : [])
              ])
              
              if (createTopicResult.rows.length > 0) {
                topicIdUuid = createTopicResult.rows[0].topic_id
                resolvedCourseId = createTopicResult.rows[0].course_id
                console.log(`‚úÖ Created new topic: ${topicIdUuid} for topic_name: "${topicNameToSearch}"`)
                console.log(`   Course ID: ${resolvedCourseId}`)
              } else {
                // Topic might have been created in a concurrent request, fetch it
                const fetchTopic = await postgres.query(
                  `SELECT "topic_id", "course_id" FROM "topics" WHERE "topic_name" = $1::text LIMIT 1`,
                  [topicNameToSearch]
                )
                if (fetchTopic.rows.length > 0) {
                  topicIdUuid = fetchTopic.rows[0].topic_id
                  resolvedCourseId = fetchTopic.rows[0].course_id
                  console.log(`‚úÖ Found topic after creation: ${topicIdUuid}`)
                } else {
                  throw new Error(`Failed to create or fetch topic: "${topicNameToSearch}"`)
                }
              }
            } catch (createError) {
              // If topic creation fails, provide clear error message
              console.error(`‚ùå Failed to create topic: ${createError.message}`)
              if (createError.message.includes('course_id') || createError.message.includes('foreign key')) {
                console.error(`   Topics table requires a valid course_id.`)
                console.error(`   Course ID used: ${resolvedCourseId}`)
                console.error(`   Please ensure the course exists in the courses table.`)
              } else if (createError.message.includes('constraint')) {
                console.error(`   Database constraint violation. Please check course_id and topic_name.`)
              }
              throw createError
            }
          }
        } catch (error) {
          // If it's our custom error, re-throw it
          if (error.message.includes('Topic') || error.message.includes('course_id')) {
            throw error
          }
          console.error('Error looking up topic:', error)
          throw new Error(`Failed to lookup topic: ${error.message}`)
        }
      } else {
        // No topic_name provided, cannot look up topic
        throw new Error('Cannot resolve topic_id: topic_name is required when topic_id is not a UUID')
      }
    }

    // Resolve question type
    const resolvedQuestionType = question_type || metaQuestionType || 'theoretical'
    
    // Resolve difficulty
    const resolvedDifficulty = difficulty || 'intermediate'
    
    // Resolve language/programming_language
    const resolvedLanguage = language || programming_language || metaProgrammingLanguage || null

    // Resolve title
    const resolvedTitle = title || questionContent.substring(0, 200) || null

    // Prepare metadata JSONB field
    const questionMetadata = {
      source: source || 'content-studio',
      original_id: id,
      topic_name: topic_name || topicName || metaTopicName,
      human_language: humanLanguage,
      skills: Array.isArray(skills) ? skills : [],
      hints: resolvedHints,
      // Store raw Gemini response if available (for debugging/analysis)
      ...(_rawGeminiResponse && {
        raw_gemini_response: _rawGeminiResponse,
        has_raw_response: true
      }),
      // Store options and correct_answer in metadata for theoretical questions
      ...(resolvedQuestionType === 'theoretical' && {
        options: Array.isArray(resolvedOptions) ? resolvedOptions : (resolvedOptions ? [resolvedOptions] : []),
        correct_answer: resolvedCorrectAnswer,
        has_options: Array.isArray(resolvedOptions) ? resolvedOptions.length > 0 : !!resolvedOptions,
        question_format: resolvedOptions && resolvedOptions.length > 0 ? 'multiple_choice' : 'open_ended'
      }),
      // Store test cases metadata for coding questions
      ...(resolvedQuestionType === 'code' && {
        test_cases_count: resolvedTestCases.length,
        has_test_cases: resolvedTestCases.length > 0
      }),
      created_from: 'content-studio',
      created_at: new Date().toISOString()
    }

    // Prepare tags (can be extracted from skills or other metadata)
    const tags = [
      ...(Array.isArray(skills) ? skills : []),
      resolvedQuestionType,
      resolvedDifficulty,
      ...(resolvedLanguage ? [resolvedLanguage] : [])
    ].filter(Boolean)

    // Check for duplicate question (by content and topic) - AFTER resolving topic_id
    // This prevents saving the same question multiple times for the same topic
    try {
      const duplicateCheck = await postgres.query(
        `SELECT "question_id" FROM ${questionsTable} 
         WHERE "question_content" = $1::text 
           AND "topic_id" = $2::uuid 
         LIMIT 1`,
        [questionContent, topicIdUuid]
      )

      if (duplicateCheck.rows.length > 0) {
        console.log(`‚ö†Ô∏è Duplicate question found, skipping insertion: ${duplicateCheck.rows[0].question_id}`)
        console.log(`   Question content: ${questionContent.substring(0, 50)}...`)
        console.log(`   Topic ID: ${topicIdUuid}`)
        return {
          success: false,
          question_id: duplicateCheck.rows[0].question_id,
          message: 'Duplicate question already exists',
          skipped: true
        }
      }
    } catch (error) {
      // If duplicate check fails, log warning but continue with insertion
      // This might happen if topic_id format is incorrect, but we'll let database handle it
      console.warn(`‚ö†Ô∏è Duplicate check failed: ${error.message}`)
      console.warn(`   Continuing with insertion - database constraints will handle duplicates`)
    }

    // Generate UUID for question
    const questionId = randomUUID()

    // Insert question into Supabase
    const insertQuery = `
      INSERT INTO ${questionsTable} (
        "question_id",
        "topic_id",
        "course_id",
        "title",
        "question_type",
        "question_content",
        "difficulty",
        "language",
        "tags",
        "metadata",
        "created_at",
        "updated_at"
      ) VALUES (
        $1::uuid,
        $2::uuid,
        $3::uuid,
        $4::text,
        $5::text,
        $6::text,
        $7::text,
        $8::text,
        $9::jsonb,
        $10::jsonb,
        now(),
        now()
      )
      ON CONFLICT ("question_id") DO NOTHING
      RETURNING "question_id", "question_content", "question_type", "created_at"
    `

    const insertValues = [
      questionId,
      topicIdUuid,
      resolvedCourseId,
      resolvedTitle,
      resolvedQuestionType,
      questionContent,
      resolvedDifficulty,
      resolvedLanguage,
      JSON.stringify(tags),
      JSON.stringify(questionMetadata),
    ]

    const insertResult = await postgres.query(insertQuery, insertValues)

    if (insertResult.rows.length === 0) {
      // Conflict occurred (unlikely with random UUID, but handled)
      console.warn(`‚ö†Ô∏è Question ID conflict, using existing question: ${questionId}`)
      const existingQuestion = await postgres.query(
        `SELECT "question_id" FROM ${questionsTable} WHERE "question_id" = $1::uuid`,
        [questionId]
      )
      if (existingQuestion.rows.length > 0) {
        return {
          success: false,
          question_id: existingQuestion.rows[0].question_id,
          message: 'Question ID conflict'
        }
      }
      throw new Error('Failed to insert question and no existing question found')
    }

    const savedQuestion = insertResult.rows[0]
    console.log(`‚úÖ Question saved to Supabase: ${savedQuestion.question_id}`)
    console.log(`   Type: ${savedQuestion.question_type}`)
    console.log(`   Content: ${savedQuestion.question_content.substring(0, 50)}...`)

    // Save test cases for coding questions
    if (resolvedQuestionType === 'code' && resolvedTestCases.length > 0) {
      await saveTestCasesToSupabase(savedQuestion.question_id, resolvedTestCases)
    }

    return {
      success: true,
      question_id: savedQuestion.question_id,
      question_content: savedQuestion.question_content,
      question_type: savedQuestion.question_type,
      created_at: savedQuestion.created_at
    }
  } catch (error) {
    console.error('‚ùå Error saving question to Supabase:', error)
    console.error('   Question data:', JSON.stringify(questionData, null, 2))
    console.error('   Metadata:', JSON.stringify(metadata, null, 2))
    throw error
  }
}

/**
 * Save test cases for a coding question
 * @param {string} questionId - UUID of the question
 * @param {Array} testCases - Array of test case objects
 */
const saveTestCasesToSupabase = async (questionId, testCases) => {
  try {
    if (!Array.isArray(testCases) || testCases.length === 0) {
      return
    }

    console.log(`üîç Saving ${testCases.length} test case(s) for question ${questionId}`)

    for (const testCase of testCases) {
      const {
        input,
        expected_output,
        expectedOutput,
        output,
        explanation
      } = testCase

      const testCaseInput = input || null
      const testCaseOutput = expected_output || expectedOutput || output || null

      if (!testCaseOutput) {
        console.warn('‚ö†Ô∏è Skipping test case without expected output')
        continue
      }

      const testCaseId = randomUUID()

      const insertTestCaseQuery = `
        INSERT INTO ${testCasesTable} (
          "testCase_id",
          "question_id",
          "input",
          "expected_output",
          "explanation",
          "created_at",
          "updated_at"
        ) VALUES (
          $1::uuid,
          $2::uuid,
          $3::text,
          $4::text,
          $5::text,
          now(),
          now()
        )
        ON CONFLICT ("testCase_id") DO NOTHING
        RETURNING "testCase_id"
      `

      const testCaseResult = await postgres.query(insertTestCaseQuery, [
        testCaseId,
        questionId,
        testCaseInput,
        testCaseOutput,
        explanation || null
      ])

      if (testCaseResult.rows.length > 0) {
        console.log(`   ‚úÖ Test case saved: ${testCaseResult.rows[0].testCase_id}`)
      }
    }
  } catch (error) {
    console.error('‚ùå Error saving test cases:', error)
    // Don't throw - test case failure shouldn't prevent question from being saved
  }
}

/**
 * Save multiple questions to Supabase
 * @param {Array} questions - Array of question objects
 * @param {Object} metadata - Shared metadata for all questions
 * @returns {Promise<Array>} Array of save results
 */
export const saveQuestionsToSupabase = async (questions, metadata = {}) => {
  if (!Array.isArray(questions) || questions.length === 0) {
    console.log('‚ö†Ô∏è No questions to save')
    return []
  }

  console.log(`üîç Saving ${questions.length} question(s) to Supabase...`)
  console.log(`   Source: ${metadata.source || 'content-studio'}`)
  console.log(`   Topic: ${metadata.topic_name || metadata.topic_id || 'Unknown'}`)
  console.log(`   Question Type: ${metadata.question_type || 'Unknown'}`)

  const results = []
  for (let i = 0; i < questions.length; i++) {
    const question = questions[i]
    try {
      console.log(`\n   Processing question ${i + 1}/${questions.length}...`)
      const result = await saveQuestionToSupabase(question, metadata)
      results.push(result)
      
      if (result.success) {
        console.log(`   ‚úÖ Question ${i + 1} saved successfully`)
      } else if (result.skipped) {
        console.log(`   ‚è≠Ô∏è  Question ${i + 1} skipped (duplicate)`)
      } else {
        console.log(`   ‚ö†Ô∏è  Question ${i + 1} not saved: ${result.message || 'Unknown error'}`)
      }
    } catch (error) {
      console.error(`   ‚ùå Failed to save question ${i + 1}:`, error.message)
      console.error(`      Error details:`, error.stack?.split('\n').slice(0, 3).join('\n'))
      results.push({
        success: false,
        error: error.message,
        question_index: i + 1,
        question_id: question.id || question.question_id || 'Unknown',
        question_preview: (question.question || question.question_content || question.prompt || '').substring(0, 50)
      })
      // Continue with next question - don't let one failure stop all saves
    }
  }

  const successCount = results.filter(r => r.success).length
  const skippedCount = results.filter(r => r.skipped).length
  const failureCount = results.filter(r => !r.success && !r.skipped).length

  console.log(`\nüìä Question save summary:`)
  console.log(`   ‚úÖ Successfully saved: ${successCount}`)
  console.log(`   ‚è≠Ô∏è  Skipped (duplicates): ${skippedCount}`)
  console.log(`   ‚ùå Failed: ${failureCount}`)
  console.log(`   üìù Total processed: ${questions.length}`)

  return results
}

