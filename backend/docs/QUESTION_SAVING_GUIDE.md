# Complete Guide: Saving Questions to PostgreSQL

## Overview

This guide explains how to save questions generated by the question generation endpoint to PostgreSQL tables (`temp_questions` and `testCases`) using transactions, proper error handling, and UUID generation.

## Table Structure

### `temp_questions` Table

```sql
CREATE TABLE "temp_questions" (
  "question_id" text PRIMARY KEY,              -- From Gemini response (e.g., "demo_123")
  "question_content" text NOT NULL,            -- Question description/content
  "title" text,                                -- Question title
  "difficulty" text,                           -- Difficulty level (e.g., "intermediate")
  "language" text,                             -- Programming language (e.g., "javascript")
  "question_type" text,                        -- Question type (e.g., "coding", "theoretical")
  "solution" text,                             -- Solution code/explanation
  "hints" jsonb DEFAULT '[]'::jsonb,          -- Array of hints (stored as JSON)
  "test_cases" jsonb DEFAULT '[]'::jsonb,     -- Array of test cases (stored as JSON)
  "course_id" uuid,                            -- Foreign key to courses table
  "topic_id" uuid,                             -- Foreign key to topics table
  "created_at" timestamptz NOT NULL DEFAULT now(),
  "updated_at" timestamptz NOT NULL DEFAULT now()
);
```

### `testCases` Table

```sql
CREATE TABLE "testCases" (
  "testCase_id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "question_id" uuid NOT NULL,                 -- Foreign key to questions.question_id (must be UUID)
  "input" text,                                -- Test case input
  "expected_output" text NOT NULL,             -- Expected output
  "explanation" text,                          -- Explanation of test case
  "metadata" jsonb,                            -- Additional metadata
  "created_at" timestamptz NOT NULL DEFAULT now(),
  "updated_at" timestamptz NOT NULL DEFAULT now()
);
```

## Step-by-Step Implementation

### Step 1: Receive JSON Response from Question Generation Endpoint

The question generation endpoint returns questions in the following format:

```json
{
  "success": true,
  "questions": [
    {
      "question_id": "demo_1234567890_0",
      "title": "Calculate Sum",
      "description": "Create a function that calculates the sum of two numbers",
      "difficulty": "intermediate",
      "language": "javascript",
      "question_type": "coding",
      "solution": "function sum(a, b) { return a + b; }",
      "hints": ["Hint 1", "Hint 2"],
      "testCases": [
        {
          "input": "1, 2",
          "expectedOutput": "3",
          "explanation": "Simple addition"
        },
        {
          "input": "5, 10",
          "expectedOutput": "15",
          "explanation": "Another addition"
        }
      ]
    }
  ]
}
```

### Step 2: Extract Question Data

For each question in the response, extract:
- `question_id` (required) - Primary key for `temp_questions`
- `description` or `question_content` (required) - Question content
- `title` - Question title
- `difficulty` - Difficulty level
- `language` - Programming language
- `question_type` - Question type
- `solution` - Solution code/explanation
- `hints` - Array of hints
- `testCases` - Array of test cases

### Step 3: Use Database Transaction

Use a PostgreSQL transaction to ensure atomicity:
- Either all inserts succeed, or none are applied
- If any insert fails, rollback the entire transaction
- Commit only if all inserts succeed

### Step 4: Insert Question into `temp_questions` Table

```sql
INSERT INTO "temp_questions" (
  "question_id",
  "question_content",
  "title",
  "difficulty",
  "language",
  "question_type",
  "solution",
  "hints",
  "test_cases",
  "course_id",
  "topic_id",
  "created_at",
  "updated_at"
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8::jsonb, $9::jsonb, $10, $11, now(), now())
ON CONFLICT ("question_id")
DO UPDATE SET
  "question_content" = EXCLUDED."question_content",
  "title" = EXCLUDED."title",
  "difficulty" = EXCLUDED."difficulty",
  "language" = EXCLUDED."language",
  "question_type" = EXCLUDED."question_type",
  "solution" = EXCLUDED."solution",
  "hints" = EXCLUDED."hints",
  "test_cases" = EXCLUDED."test_cases",
  "course_id" = EXCLUDED."course_id",
  "topic_id" = EXCLUDED."topic_id",
  "updated_at" = now()
RETURNING "question_id", "title", "created_at";
```

### Step 5: Insert Test Cases into `testCases` Table

For each test case in the question's `testCases` array:

1. **Generate UUID for test case**: Use `randomUUID()` or `gen_random_uuid()`
2. **Check if question_id is UUID**: The `testCases` table requires `question_id` to be UUID format
3. **Insert test case**:

```sql
INSERT INTO "testCases" (
  "testCase_id",
  "question_id",
  "input",
  "expected_output",
  "explanation",
  "metadata",
  "created_at",
  "updated_at"
)
VALUES ($1, $2::uuid, $3, $4, $5, $6::jsonb, now(), now())
ON CONFLICT ("testCase_id")
DO UPDATE SET
  "input" = EXCLUDED."input",
  "expected_output" = EXCLUDED."expected_output",
  "explanation" = EXCLUDED."explanation",
  "metadata" = EXCLUDED."metadata",
  "updated_at" = now()
RETURNING "testCase_id", "question_id", "created_at";
```

**Note**: If `question_id` is not UUID format (e.g., "demo_123"), test cases are stored in `temp_questions.test_cases` JSONB column instead of the `testCases` table.

### Step 6: Handle Errors and Rollback

If any error occurs during insertion:
1. Log the error with full details
2. Rollback the transaction
3. Return error response
4. Release database client

### Step 7: Commit Transaction and Return Success

If all inserts succeed:
1. Commit the transaction
2. Log success with counts
3. Return success response with saved data
4. Release database client

## Complete Code Implementation

See `backend/src/services/questionSaveService.js` for the complete implementation.

## Usage Example

### From Express Route Handler

```javascript
import { saveQuestionsWithTestCases } from '../services/questionSaveService.js'

router.post('/save-questions', async (req, res) => {
  try {
    const questions = req.body.questions || []
    const options = {
      course_id: req.body.course_id || null,
      topic_id: req.body.topic_id || null,
      courseName: req.body.courseName || null,
      topicName: req.body.topicName || null
    }
    
    const result = await saveQuestionsWithTestCases(questions, options)
    
    if (result.success) {
      return res.json({
        success: true,
        message: `Saved ${result.savedQuestions.length} question(s)`,
        data: result
      })
    } else {
      return res.status(500).json({
        success: false,
        error: 'Failed to save questions',
        data: result
      })
    }
  } catch (error) {
    return res.status(500).json({
      success: false,
      error: error.message
    })
  }
})
```

### Request Body Format

```json
{
  "questions": [
    {
      "question_id": "demo_123",
      "title": "Question Title",
      "description": "Question content",
      "difficulty": "intermediate",
      "language": "javascript",
      "question_type": "coding",
      "solution": "function solution() { ... }",
      "hints": ["hint1", "hint2"],
      "testCases": [
        {
          "input": "1, 2",
          "expectedOutput": "3",
          "explanation": "Simple addition"
        }
      ]
    }
  ],
  "course_id": "uuid-here",
  "topic_id": "uuid-here"
}
```

## Error Handling

The service handles the following errors:

1. **Duplicate Key (23505)**: Uses `ON CONFLICT DO UPDATE` to update existing records
2. **Foreign Key Violation (23503)**: Logs error and continues with next question
3. **Table Not Found (42P01)**: Creates table if it doesn't exist
4. **Permission Denied (42501)**: Logs error and returns failure
5. **Connection Error**: Rolls back transaction and returns failure

## Transaction Flow

```
BEGIN
  → For each question:
    → Insert into temp_questions
    → For each test case:
      → Insert into testCases (if question_id is UUID)
      → Or store in temp_questions.test_cases JSONB
  → COMMIT (if all successful)
  → OR ROLLBACK (if any error)
```

## Testing

Use the test endpoint to verify Supabase connection and insertion:

```bash
POST /api/gemini-questions/test-supabase-insert
```

This endpoint:
1. Tests Supabase connection
2. Checks table structure
3. Inserts a test question
4. Verifies insertion
5. Cleans up test data

## Notes

1. **SERVICE_API_KEYS**: Not needed for database writes. Database operations use `SUPABASE_URL` connection string.
2. **UUID Generation**: Use `randomUUID()` from `crypto` module or `gen_random_uuid()` in SQL.
3. **Transaction**: All inserts are wrapped in a transaction for atomicity.
4. **Error Handling**: Errors are logged but don't fail the entire operation (continues with next question).
5. **Test Cases**: If `question_id` is not UUID, test cases are stored in `temp_questions.test_cases` JSONB column.


